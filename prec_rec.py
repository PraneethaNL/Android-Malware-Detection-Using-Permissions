#import binary_optimization as opt#import library
import numpy as np
from sklearn import svm
from sklearn import model_selection as ms
import time
import numpy
import pandas

from multiprocessing import Pool
import numpy as np
import random
from itertools import combinations as cb
import math
from copy import deepcopy as dc
from tqdm import tqdm
from matplotlib import pyplot
#import matplotlib.pyplot as plt

from sklearn import svm
from sklearn.metrics import roc_curve, auc
from sklearn.model_selection import StratifiedKFold
from sklearn.metrics import precision_score,recall_score,accuracy_score

def logsig(n): return 1 / (1 + math.exp(-n))
def sign(x): return 1 if x > 0 else (-1 if x!=0 else 0)

def BPSO(Eval_Func,n=20,m_i=200,minf=0,dim=None,prog=False,w1=0.5,c1=1,c2=1,vmax=4,mp=None):

    estimate=Eval_Func().evaluate
    if dim==None:
        dim=Eval_Func().check_dimentions(dim)


    gens=random_search(n,dim)
    pbest=float("-inf") if minf == 0 else float("inf")
    gbest=float("-inf") if minf == 0 else float("inf")
    #vec=3
    #flag=dr
    gens=random_search(n,dim)
    vel=[[random.random()-0.5 for d in range(dim)] for _n in range(n)]
    one_vel=[[random.random()-0.5 for d in range(dim)] for _n in range(n)]
    zero_vel=[[random.random()-0.5 for d in range(dim)] for _n in range(n)]

    fit=[float("-inf") if minf == 0 else float("inf") for i in range(n)]
    pbest=dc(fit)
    xpbest=dc(gens)
    #w1=0.5
    if minf==0:
        gbest=max(fit)
        xgbest=gens[fit.index(max(fit))]
    else:
        gbest=min(fit)
        xgbest=gens[fit.index(min(fit))]

    #c1,c2=1,1
    #vmax=4
    gens_dict={tuple([0]*dim):float("-inf") if minf == 0 else float("inf")}
    if prog:
        miter=tqdm(range(m_i))
    else:
        miter=range(m_i)

    for it in miter:
        #w=0.5
        if mp==None:
            for i in range(n):
                if tuple(gens[i]) in gens_dict:
                    score=gens_dict[tuple(gens[i])]
                else:
                    score=estimate(gens[i])
                    gens_dict[tuple(gens[i])]=score
                fit[i]=score
                if fit[i]>pbest[i] if minf==0 else fit[i]<pbest[i]:#max
                    pbest[i]=dc(fit[i])
                    xpbest[i]=dc(gens[i])
                    """multi"""
        else:
            #fit=[float("-inf") if minf == 0 else float("inf") for i in range(n)]
            fit=[gens_dict[tuple(g)]  if tuple(g) in gens_dict  else(float("-inf") if minf == 0 else float("inf")) for g in gens]
            alter_gens=[i for i,g in enumerate(gens) if tuple(g) not in gens_dict]
            #print(len(alter_gens))
            with Pool(mp) as p:
                alter_fit = p.map(estimate,[gens[i] for i in alter_gens])
            # pbest=dc(fit)
            # xpbest=dc(gens)
            for i,f in zip(alter_gens,alter_fit):
                fit[i]=f
                gens_dict[tuple(gens[i])]=f

            #print(alter_fit)
            #print(list(map(estimate,[gens[i] for i in alter_gens])))
            # pbest=dc(fit)
            # xpbest=dc(gens)
            # for i,f in zip(alter_gens,alter_fit):
            #     fit[i]=f
            #print(fit)

            if minf==0:#max
                for i,f in enumerate(fit):
                    if f>pbest[i]:
                        pbest[i]=dc(max(fit))
                        xpbest[i]=dc(gens[fit.index(max(fit))])
            else:
                for i,f in enumerate(fit):
                    if f>pbest[i]:
                        pbest[i]=dc(max(fit))
                        xpbest[i]=dc(gens[fit.index(max(fit))])
        """end"""
        if minf==0:
            gg=max(fit)
            xgg=gens[fit.index(max(fit))]
        else:
            gg=min(fit)
            xgg=gens[fit.index(min(fit))]

        if gbest<gg if minf==0 else gbest>gg:#max
            gbest=dc(gg)
            xgbest=dc(xgg)

        oneadd=[[0 for d in range(dim)] for i in range(n)]
        zeroadd=[[0 for d in range(dim)] for i in range(n)]
        c3=c1*random.random()
        dd3=c2*random.random()
        for i in range(n):
            for j in range(dim):
                if xpbest[i][j]==0:
                    oneadd[i][j]=oneadd[i][j]-c3
                    zeroadd[i][j]=zeroadd[i][j]+c3
                else:
                    oneadd[i][j]=oneadd[i][j]+c3
                    zeroadd[i][j]=zeroadd[i][j]-c3

                if xgbest[j]==0:
                    oneadd[i][j]=oneadd[i][j]-dd3
                    zeroadd[i][j]=zeroadd[i][j]+dd3
                else:
                    oneadd[i][j]=oneadd[i][j]+dd3
                    zeroadd[i][j]=zeroadd[i][j]-dd3

        one_vel=[[w1*_v+_a for _v,_a in zip(ov,oa)] for ov,oa in zip(one_vel,oneadd)]
        zero_vel=[[w1*_v+_a for _v,_a in zip(ov,oa)] for ov,oa in zip(zero_vel,zeroadd)]
        for i in range(n):
            for j in range(dim):
                if abs(vel[i][j]) > vmax:
                    zero_vel[i][j]=vmax*sign(zero_vel[i][j])
                    one_vel[i][j]=vmax*sign(one_vel[i][j])
        for i in range(n):
            for j in range(dim):
                if gens[i][j]==1:
                    vel[i][j]=zero_vel[i][j]
                else:
                    vel[i][j]=one_vel[i][j]
        veln=[[logsig(s[_s]) for _s in range(len(s))] for s in vel]
        temp=[[random.random() for d in range(dim)] for _n in range(n)]
        for i in range(n):
            for j in range(dim):
                if temp[i][j]<veln[i][j]:
                    gens[i][j]= 0 if gens[i][j] ==1 else 1
                else:
                    pass
    print(len(gens_dict))
    return gbest,xgbest,xgbest.count(1)

"""BCS"""
def sigmoid(x):
    try:
        return 1/(1+math.exp(-x))
    except OverflowError:
        return 0.000001
def sigma(beta):
    p=math.gamma(1+beta)* math.sin(math.pi*beta/2)/(math.gamma((1+beta)/2)*beta*(pow(2,(beta-1)/2)))
    return pow(p,1/beta)
def levy_flight(beta,best,est,alpha):
    sg=sigma(beta)
    u=np.random.normal(0,sg**2)
    v=abs(np.random.normal(0,1))
    step=u/pow(v,1/beta)
    step_size=alpha+step#+(step*(est-best))
    new=est+step_size#*np.random.normal()#random.normalvariate(0,sg)
    return new

def BCS(Eval_Func,m_i=200,n=20,minf=0,dim=None,prog=False,alpha=0.1,beta=1.5,param=0.25,mp=None):

    estimate=Eval_Func().evaluate
    if dim==None:
        dim=Eval_Func().check_dimentions(dim)
    pa=param
    #flag=dr
    gens=random_search(n,dim)
    fit=[float("-inf") if minf == 0 else float("inf") for _ in range(n)]
    pos=[0 for _ in range(n)]
    g_pos=[0]*dim
    g_val=float("-inf") if minf == 0 else float("inf")
    gens_dict={tuple([0]*dim):float("-inf") if minf == 0 else float("inf")}
    if prog:
        miter=tqdm(range(m_i))
    else:
        miter=range(m_i)
    for it in miter:
        if mp!=None:
            fnew=[gens_dict[tuple(g)]  if tuple(g) in gens_dict  else(float("-inf") if minf == 0 else float("inf")) for g in gens]
            alter_gens=[i for i,g in enumerate(gens) if tuple(g) not in gens_dict]
            #print(len(alter_gens))
            with Pool(mp) as p:
                alter_fit = p.map(estimate,[gens[_i] for _i in alter_gens])
            z=0
            for i in range(len(fit)):
                if i in alter_gens:
                    fnew[i]=alter_fit[z]
                    gens_dict[tuple(gens[i])]=alter_fit[z]
                    z+=1
                else:pass
                if fnew[i] > fit[i] if minf==0 else fnew[i] < fit[i]:
                    fit[i]=dc(fnew[i])
                    pos[i]=dc(gens[i])

        else:
            for i,g in enumerate(gens):
                if tuple(g) in gens_dict:
                    score=gens_dict[tuple(g)]
                else:
                    score=estimate(g)
                    gens_dict[tuple(g)]=score
                if score > fit[i] if minf==0 else score < fit[i]:
                    fit[i]=score
                    pos[i]=g

        maxfit,maxind=max(fit),fit.index(max(fit))
        minfit,minind=min(fit),fit.index(min(fit))
        if minf==0:
            if maxfit > g_val:
                g_val=dc(maxfit)
                g_pos=dc(gens[maxind])
        else:
            if minfit < g_val:
                g_val=dc(minfit)
                g_pos=dc(gens[minind])

        if pa < random.uniform(0,1):
            if minf==0:
                gens[minind]=[0 if 0.5>random.uniform(0,1) else 1 for _ in range(dim)]#rand_gen()
                fit[minind]=float("-inf") if minf == 0 else float("inf")
            else:
                gens[maxind]=[0 if 0.5>random.uniform(0,1) else 1 for _ in range(dim)]#rand_gen()
                fit[maxind]=float("-inf") if minf == 0 else float("inf")


        for g in gens:
            for d in range(dim):
                x=levy_flight(beta,g_pos[d],g[d],alpha)
                if random.uniform(0,1) < sigmoid(x):
                    g[d]=1
                else:
                    g[d]=0
    print(len(gens_dict))
    return g_val,g_pos,g_pos.count(1)

"""Evaluate Function """
class Evaluate:
    def __init__(self):
        None
    def evaluate(self,gen):
        None
    def check_dimentions(self,dim):
        None

"""Common Function"""
def random_search(n,dim):
   
    gens=[[0 for g in range(dim)] for _ in range(n)]
    for i,gen in enumerate(gens) :
        r=random.randint(1,dim)
        for _r in range(r):
            gen[_r]=1
        random.shuffle(gen)
    return gens

"""BGA"""
def suddn(li,n_li,num):
    l1= [random.choice(n_li) for i in range(num)]
    l2= [random.choice([0,1]) for i in range(num)]
    al_li=dc(li)
    for i in range(len(l1)):
        al_li[l1[i]]=l2[i]
    #li=''.join(_d)
    return al_li

def BGA(Eval_Func,n=20,m_i=300,mutation=0.05,minf=0,dim=None,prog=False,mp=None):

    estimate=Eval_Func().evaluate
    if dim==None:
        dim=Eval_Func().check_dimentions(dim)
    gens=random_search(n,dim)
    fit=[0 for i in range(n)]
    num_li=range(dim)
    #flag=dr
    best_val=float("-inf") if minf == 0 else float("inf")
    best_pos=[0]*dim
    gens_dict={tuple([0]*dim):float("-inf") if minf == 0 else float("inf")}
    prop=mutation

    if prog:
        miter=tqdm(range(m_i))
    else:
        miter=range(m_i)

    for it in miter:
        if mp !=None:
            fit=[gens_dict[tuple(g)]  if tuple(g) in gens_dict  else(float("-inf") if minf == 0 else float("inf")) for g in gens]
            alter_gens=[k for k,g in enumerate(gens) if tuple(g) not in gens_dict]
            #print(len(alter_gens))
            with Pool(mp) as p:
                alter_fit = p.map(estimate,[gens[k] for k in alter_gens])
            print(alter_fit)
            z=0
            for zz in range(len(fit)):
                if zz in alter_gens:
                    fit[zz]=alter_fit[z]
                    gens_dict[tuple(gens[zz])]=alter_fit[z]
                    z+=1
                else:pass
                if best_val < fit[zz] if minf==0 else best_val > fit[zz]:
                    best_val=dc(fit[zz])
                    best_pos=dc(gens[zz])
        else:
            for i,gen in enumerate(gens):
                ################################

                    ################################
                    if tuple(gen) in gens_dict:
                        v=gens_dict[tuple(gen)]
                    else:
                        score=estimate(gen)
                        gens_dict[tuple(gen)]=score
                    fit[i]=score
                    if best_val < score if minf==0 else best_val > score:
                        best_val=dc(score)
                        best_pos=dc(gen)
        alter_gens=sorted(gens,reverse=True)[:2]
        t1=random.randint(1,len(gens[0])-2)
        t2=random.randint(t1,len(gens[0])-1)

        fit_ind=np.argsort(fit)[::-1][:n//2]
        sample_num=random.sample(list(cb(fit_ind,2)),n-2)
        qgens=[suddn(gens[s][:t1]+gens[m][t1:t2]+gens[s][t2:],num_li,dim//3) if np.random.choice([0,1],size=1,p=[1-prop,prop])[0]==1
               else gens[s][:t1]+gens[m][t1:t2]+gens[s][t2:] for s,m in sample_num]
        gens=[]
        gens.extend(qgens)
        gens.append(alter_gens[0])
        gens.append(alter_gens[1])
    print(len(gens_dict))
    return best_val,best_pos,best_pos.count(1)


a2 = open('/home/praneetha/major project/unique_all.txt','r').read().strip().split('\n')
a2_set = set(a2)

mat = [[0 for i in range(1098)] for j in range(1282+2440)]
for i in range(1282):
	#j=271
	input_fname="/home/praneetha/major project/benign_permissions/"+`i+1`+".txt"
	'''output_fname_nonstd = "/home/sakshi/Desktop/major/ben_out/non_std/"+`i+1`+"non_std.txt"
	output_fname_std = "/home/sakshi/Desktop/major/ben_out/std/"+`i+1`+"std.txt" '''

	#print(i,j)

	

	a1 = open(input_fname,'r').read().strip().split('\n')

	

	a1_set = set(a1)

	
	l=i
	k=0
	for p in a1_set:
		for q in a2_set:
			if p==q:
				
				mat[l][k]=1
			#print(l,k,mat[l][k])
			k+=1
			'''else:
				
				#print(i,j)
				mat[l][k]=0
				print(l,j,mat[l][k])'''
			#print(k)
			#k=k+1
			'''if k==272:
				k=0
				break'''
		#print"end of row "+str(i)
		k=0
	'''j=0			
	for p in a1_set:
		for q in a2_set:
			if mat[i,j]!=1:
				mat[i,j]=0


			j=j+1'''
'''
num_mat = numpy.array(mat)
print num_mat
print num_mat.shape'''


#num_mat = numpy.array(mat)




#mat = [[0 for i in range(1098)] for j in range(2440)]
for i in range(2440):
	#j=271
	input_fname="/home/praneetha/major project/malware_permissions/"+`i+1`+".txt"
	'''output_fname_nonstd = "/home/sakshi/Desktop/major/ben_out/non_std/"+`i+1`+"non_std.txt"
	output_fname_std = "/home/sakshi/Desktop/major/ben_out/std/"+`i+1`+"std.txt" '''

	#print(i,j)

	

	a1 = open(input_fname,'r').read().strip().split('\n')

	

	a1_set = set(a1)

	
	l=i
	k=0
	for p in a1_set:
		for q in a2_set:
			if p==q:
				
				mat[l+1282][k]=1
			#print(l,k,mat[l][k])
			k+=1
			'''else:
				
				#print(i,j)
				mat[l][k]=0
				print(l,j,mat[l][k])'''
			#print(k)
			#k=k+1
			'''if k==272:
				k=0
				break'''
		#print"end of row "+str(i)
		k=0
	'''j=0			
	for p in a1_set:
		for q in a2_set:
			if mat[i,j]!=1:
				mat[i,j]=0


			j=j+1'''

num_mat = numpy.array(mat)
#print num_mat
print num_mat.shape
tr_y = [0 for i in range(3722)]

for i in range(1282):
	#mat[i][500]=0
	tr_y[i]=0
	

for i in range(2440):
	#mat[i+500][500]=1
	tr_y[i+1282]=1
num_mat = numpy.array(mat)


tr_x = num_mat
tr_y= numpy.array(tr_y)
class Evaluate:#setting class
    def __init__(self):#set train_data,train_label
        self.tr_x = num_mat
        self.tr_y = tr_y
        self.K = 4
    def evaluate(self,gen):
        """
        Setting of evaluation function.
        Here, the correct answer rate is used.
          anser_label/all_label
        """
	accuracy_scores = []
    	precision_scores = []
    	recall_scores = []
    	f1_scores = []
        mask = np.array(gen) > 0
        al_data = tr_x[:,np.nonzero(mask)[0]]
        kf = ms.KFold(n_splits=self.K, shuffle=True);s=0
        #for tr_ix, te_ix in kf.split(self.tr_x):          
         # s += svm.LinearSVC().fit(al_data[tr_ix],self.tr_y[tr_ix]).score(al_data[te_ix], self.tr_y[te_ix])
       # return s/self.K
	some=0
        for train_index, test_index in kf.split(self.tr_x,tr_y): 
          x_train, x_test = al_data[train_index], al_data[test_index]
          y_train, y_test = tr_y[train_index], tr_y[test_index]
	  print ()
	  #print(numpy.array(y_test).shape)
	  clf=svm.SVC(C=2,kernel='rbf',gamma=0.2)
	  start=time.time()
          clf.fit(x_train, y_train)
	  end=time.time()
	  print("time\n",end-start)
	  start=time.time()
          y_pred= clf.predict(x_test)
	  end=time.time()
	  print("test time",end-start)
          accuracy_scores.append(accuracy_score(y_test, y_pred))
	  #print y_test, y_pred
	  
	  #print y_test,y_pred
	  '''for i in y_test,j in y_pred:
	  	#print some
		if j!=i:
			print y_pred.index(i)
	  some=some+1'''
	  n_y_test=numpy.array(y_test)
	  n_y_pred=numpy.array(y_pred)
	  result=n_y_test == n_y_pred
	  '''for i in n_y_test,j in n_y_pred:
	  	if n_y_test[i]!=n_y_pred[j]:
			print some
		some=some+1'''
	  count=0
	  for index,item in enumerate(result):
	  	if item==False:
	  		print index,item
			count=count+1

	  #ans=np.where(result=="false")
	  #print ans
	  #y_test_set = set(y_test)
	  #pred_test_set=set(y_pred)
	  #print y_test_set
	  #print pred_test_set
	  '''for i in y_test_set, j in pred_test_set:
		
		if i!=j:
			print some
		some=some+1
		print some
	  #k='''
          precision_scores.append(precision_score(y_test, y_pred))
          recall_scores.append(recall_score(y_test, y_pred))
          #f1_scores.append(f1_score(y_test, y_pred))
	print("count",count)
	count=0
	print('Accuracy', np.mean(accuracy_scores))
        print('Precision', np.mean(precision_scores))
        print('Recall', np.mean(recall_scores))
        #print('F1-measure', np.mean(f1_scores))
	return np.mean(accuracy_scores)
    def check_dimentions(self,dim):#check number of all feature
        if dim==None:
            return len(self.tr_x[0])
        else:
            return dim
print("Algorithm:\n\t{0}  {1} {2}".format("best_pos","best_val","number_of_1s"))


s,g,l=BGA(Eval_Func=Evaluate, n=2, m_i=2)#score, gen_list, gen length of 1
print("BGA:\n\t{0}   {1}  {2}".format("".join(map(str,g)),s,l))

s,g,l=BCS(Eval_Func=Evaluate, n=2, m_i=2)#score, gen_list, gen length of 1
print("BCS:\n\t{0}   {1}  {2}".format("".join(map(str,g)),s,l))

s,g,l=BPSO(Eval_Func=Evaluate, n=2, m_i=2)#score, gen_list, gen length of 1
print("BPSO:\n\t{0}   {1}  {2}".format("".join(map(str,g)),s,l))
